Студенты должны решить кейс и прикрепить решение к семинару. Преподаватель проверяет его и даёт обратную связь комментариями. Обсуждение прошлого ДЗ на следующем семинаре не предполагается.

Кейс:
Вы хотите стать программистом или управленцем и, возможно, получить позицию Project Manager IT-проектов. Это очень престижно, востребовано и неплохо оплачивается.

Вы в начале обучения и пока не знаете, какое направление выбрать: есть frontend, backend и fullstack-разработка, различные языки программирования и целая область управления IT-проектами.

Нужно начинать обучение и двигаться к своей цели — получить работу в IT. Вы решили гибко подойти к этому вопросу и выбрали Agile-подход. Опишите, как вы построите своё обучение и старт в карьере.


Задание уже просрочено, форму для загрузки открыть не смогут (новые правила geekbrains)

В целом из тех книг и заметок, что я себе сохранил, уже есть хорошие материалы для планирования карьеры тестировщиком (но не проджектом, как в этом задании, если честно).

Немного переформулирую задание и построю примерный (гибкий, агиле) план по старту карьеры в тестировании (QA)

0) Свободное владение основными офисными программами (Microsoft Office 365)
1) Свободное владение ПК на уровне уверенного пользователя (умение устаналивать и настраивать ОС, необходимое ПО)
1.1) "Tester Mindset" [https://softwaretester.careers/the-software-testers-mindset/] + [https://medium.com/@blakenorrish/how-to-think-like-a-tester-7a174ff6aeaf]
2) Сформированное представление о работе тестировщика и желание заниматься именно этой работой [https://www.ministryoftesting.com/dojo/lessons/what-do-software-testers-do-version-0-1]
3) Знание английского языка на уровне беглого чтения англоязычной документации (B1 - B2)

Этот вводный этап может занять примерно 12-18 месяцев.

4) Рекомендованные книги
4.1) "Тестирование dot com" Роман Савин
4.2) "Тестирование программного обеспечения" Святослав Куликов
4.3) "Agile тестирование" Лайзы Криспин и Джанет Грегори
4.4) "PostgreSQL, основы языка SQL" Е.П. Моргунова

5) Освоение функционального тестирования (ниже будут подзадачи этого блока)
6) Научиться читать специальную литературу (и техническую документацию)
7) Научиться планировать своё рабочее время
8) Затем научиться планировать тестирование документации и требований
9) Далее научиться работать с системами управления требованиями
10) Освоить виды тестирования
11) Начать осваивать разработку тестов и тестовых сценариев
12) Научиться работать с системами управления тестами
13) Освоить методы и методологии тестирования (см. фото в папке с полезными материалами по IT)
14) Научиться искать и документировать дефекты
15) Научиться работать с баг-трекинговыми системами
16) Научиться составлять и предоставлять отчёты о результатах тестирования и их отдельные фрагменты (+ коммуникативные навыки)
17) Перейти в область функционального и доменного тестирования
18) Освоить оценку трудозатрат
19) Перейти в область тестирования веб-приложений
20) Освоить интернет-технологии
21) Освоить базы данных и язык SQL, научиться писать простые запросы (для тренировки sqlzoo.net)
22) Научиться работать в различных ОС, в том числе ОС семейства Windows и *nix
23) Научиться создавать хорошие чек-листы
24) Научиться использовать вспомогательные инструментальные средства
25) Понимать методы и виды тестирования, уметь применять их адекватно ситуации
26) Уметь вести деловое общение "очно" и опосредованно через почту и иные способы
27) Понимать принципы работы компьютерных сетей (CS50 гарвардский и любые другие курсы)

Этап изучения функционального тестирования занимает от 6 до 12 месяцев.
Здесь наступает момент выбора: выполнять задачи специалиста по функциональному тестированию, переключиться на бизнес-анализ или на автоматизированное тестирование

28) Траектория бизнес-аналитика

28.1) Проектная работа
28.2) Дальнейшее развитие и/или специализация
28.3) Опытный специалист
28.3.1) Менеджер проектов
28.3.2) Управление ресурсами (мб Team Lead)
28.4) Эксперт → разработка решений

29) Траектория автоматизированного тестирования

29.1) Изучить основы автоматизированного тестирования
29.2) Изучить инструменты и языки программирования java, c#, python, javascript, vbscript, ruby, scala, 4test, jscript, xml, html, wsdl, soap, sql
29.3) Изучить инструменты модульного тестирования: TestNG, JUnit, JMock, NUnit
29.4) Изучить инструменты тестирования настольных приложений: SilikTest, QTP, AutoIt, TestComplete
29.5) Изучить инструменты тестирования веб-приложений и веб-сервисов: Selenium IDE, Selenium Web Driver, Selenium RC & Grid, SOAP UI, HtmlUnit, Jaxb & Jax-ws
29.6) Изучить инструменты тестирования мобильных приложений: Selenium Android Driver, Selenium iOS Driver
29.7) Перейти к специальным технологиям и инструментам: BDD, DDT, TDD, Cucumber, jBehave
29.8) Научиться программировать на уровне, достаточном для создания автоматизированных тестов
29.9) Понимать специфические технологии и инструментальные средства, уметь выбирать и применять их для решения поставленной задачи
29.10) Уверенно понимать принципы работы программных средств
29.11) Уметь планировать, реализовывать и оценивать результаты экспериментов
29.12) Уметь оптимизировать тесты и тестовые сценарии
29.13) Уметь использовать вспомогательные программные средства, используемые проектной командой для автоматизации повседневных задач
29.14) Понимать и уметь использовать несколько высокоуровневых языков программирования, языков и технологий вёрстки (на уровне написания элементарных приложений)

Этап изучения автоматизации тестирования занимает от 6 до 18 месяцев. К этому моменту уже необходимо разбираться в функциональном тестировании, обладать уверенными знаниями в программировании. Автоматизация тестирования = программирование как повседневная деятельность.

30) Освоить ООП (проверочное задание - написать программу по типу Elastic Nodes: https://www.youtube.com/watch?v=I0n07iuowvY)
31) Освоить структуры данных и алгоритмы (дерево, стек, очереди, хеш, теория графов, быстрая сортировка и пр.) (для проверки: https://robocode.sourceforge.io/)
32) "Библия QA": https://github.com/VladislavEremeev/QA_bible
33) Изучить технологию REST (https://habr.com/ru/post/483202/) и (restcountries.eu)
34) Изучить Postman
35) Курс по системам учёта, таск-трекерам, баг-трекерам: https://stepik.org/course/10425/promo (по Jira)
36) Для ведения тест-кейсов, планов и сценариев: https://coderlessons.com/tutorials/kachestvo-programmnogo-obespecheniia/izuchite-testlink/testlink-kratkoe-rukovodstvo (TestLink)
37) Платный курс от Otus по ручному тестированию: https://otus.ru/online/manualtesting/
38) Мониторить материалы не только на Хабре, но и с конференций HeizenBug тоже
39) Завести профиль на LinkedIn, следить там за вакансиями, обновлять резюме, следить за другими специалистами, их наполнением профиля, идти по их следам, чтобы быть в теме.
40) ISTQB сертификация - может что-то значить для джуна


Дорожная карта тестировщика с сайта testengineer (roadmap v. 1.1.1) (https://testengineer.ru/razvitie-testirovshchika/):
1) Блок "базы тестирования"

2) test discovery techniques
- классы эквивалентности
- анализ граничных значений
- use cases
- комбинаторный анализ данных
- exhausive search
3) Приоретизация тестирования (риск-ориентированное тестирование)
4) test taxonomy (test approaches)
- black, white, grey (тестирование методом белого/чёрного/серого ящиков)
- functional, non-functional (функциональное/нефункциональное тестирование) 
[нефункциональное тестирование  касается производительности, безопасности, удобства пользования, совместимости, локализации и т.п.]
- smoke, sanity, acceptance, regression, chaos
- negative and positive (сценарии тестирования)
- unit, integration, e2e
- static vs dynamic
5) sctructured exploratory testing
6) defects and defect management
7) test documentation: test cases, test plans, test case management
- zephyr
- testrail
- qTest
- testlink (это инструменты управления тест-кейсами)
- jira (инструмент управления проектами)
8) STLC
9) test oracles
10) non-functional testing
- performance
- load (Lighthouse, Webpage Test, Gatling, K6, Artillery, Vegeta, JMeter, Locust - инструменты load и performance тестов)
- security
- accessibility (Wave, Axe, Chrome DevTools)
- compatibility
- stress
localization/internationalization
11) production readiness
- UAT
- alpha/beta testing
12) shift left and defect cost
13) quality metrics and reports
14) Блок "основы циклов разработки ПО"

15) Исторически возникшие методы разработки (V-образная, спиральная и пр.)
16) Роли и ответственность участников
17) Agile vs Waterfall
18) Agile Flavors
- Scrum
- Kanban
- SAFe
19) project risks, failure modes
20) Блок "основы работы сети Интернет"

21) Принципы работы сетей
22) OSI модель
23) Архитектура интернета и протоколы
- TCP/IP протокол
- DNS протокол
- HTTP/HTTPS протокол
24) Блок "основы computer science"

25) computer hardware (железо) и принципы управления железом операционной системой и пользовательскими программами
26) Виды (типы) представления данных
- binary
- text: json, xml, yaml
27) языки программирования
- высокоуровневые и низкоуровневые
- компилируемые и интерпретируемые
- функциональные, процедурные, ООПшные и т.п.
28) типы систем
- динамические и статические
- сильные и слабые
29) Алгоритмы и сложность их применения (начиная с простых алгоритмов, заканчивая сложными)
- Знать базовые методы сортировки и поиска, обхода и поиска в структурах данных (1 уровень)
- Деревья, Графы, "простой путь" и  "разделяй и властвуй"-алгоритмы. Понимать ассоциацию уровней этой матрицы. (2 уровень)
- Уметь распознавать и составлять решения динамическим программированием, уверенно знать алгоритмы на графах, отлично разбираться в численных методах, уметь идентифицировать проблемы класа NP (3 уровень)
30) Структуры данных и анализ данных
- Уметь объяснять и использовать на практике массивы, связные списки, словари и пр. (1 уровень)
- Понимать плюсы и минусы использования тех или иных базовых структур данных (размер памяти, время выполнения операций с данными, понимать разницу между массивами и связными списками в этом плане).
Понимать как реализовать хэш-таблицы и как обработать коллизии. Приоритетные очереди и способы их реализации, и т.д. (2 уровень)
- Знать сложные структуры данных (B-дерево, Биномиальная куча и Фибоначчиевская куча, АВЛ-дерево, Красно-чёрное дерево, Косое дерево, Список с пропусками, TRIE-структуры и т.д.)
31) Параллелизм и многопоточность 
32) Операционные системы
33) Блок "основы веб-приложений"

34) Веб-технологии: HTML, CSS, JS (как они работают в браузере, т.е. как он отрисовывает интефейсы)
35) Веб-браузеры
36) AJAX
37) Template Engines
38) SPAs (одностраничные приложения)
39) PWAs (приложения с подгружаемым контентом)
40) JAMStack
41) Криптография
42) CMSs (системы управления контентом)
43) Отрисовка в приложениях и на серверах
44) Адаптивные и реактивные приложения
45) Для практики создать веб-приложение с нуля в разных фреймворках (Angular, React)
46) Разобраться в "тестировании под капотом" (например, с наброском дата-модели и тестирования интерфейса с последующими юнит-тестами или в т.н. headless-браузере: Zombie.js, Playwright, Puppeteer, Cypress, Headless Chrome, Headless Fox, HTML Unit).
47) Блок "основы программирования"

48) Работа в командных строках и оболочках
- bash
- powershell
49) Редакторы и IDE
- Visual Studio
- VS Code
- Sublime
- Intellij
- others
50) Синтаксис языка, операторы, стиль
51) Паттерны проектирования (dry, solid и пр.)
52) Функциональное программирование
- "чистые функции"
- неизменяемые данные
- functional composition
53) Объектно-ориентированное программирование (JavaScript, TypeScript, Java, C#, Python)
- наследование
- полиморфизм
- инкапсуляция
54) Git (ясное дело)
* Декомпозиция задачи
- Процедурный подход, просто последовательные строчки, copy/paste для повторного использования кода (0 уровень)
- Умение разбивать задачу на несколько функций (методов) (1 уровень)
- Умение создавать многократно используемые функции/объекты, которые решают общие задачи (2 уровень)
- Умение использовать соответствующие структуры данных и алгоритмы, создавать общий/объектно-ориентированный код, инкапсулирующий условия задачи, которые могут быть изменены (3 уровень)
* Декомпозиция системы
- Не способен думать о системе более сложной, чем 1 класс или файл (0 уровень)
- Уметь произвести декомпозицию задачи и спроектировать систему в пределах одной платформы или технологии. (1 уровень)
- Уметь проектировать системы, которые охватывают несколько технологий/платформ. (2 уровень)
- Умение визуализировать и проектировать сложные системы с несколькими линейками продуктов, учитывать интеграцию с внешними системами. Умение проектировать системы поддержки работы: мониторинг, генерация отчетов, аварийные переходы на использование запасных ресурсов. (3 уровень)
* Коммуникативные навыки
- Не может выразить свои мысли/идеи, проблемы с правописанием, грамматикой, команда не понимает человека (0 уровень)
- Команда понимает сотрудника, правописание и грамматика хорошие (1 уровень)
- Умеет эффективно общаться (2 уровень)
- Понимает и может объяснить мысли/дизайн/идеи/специфику в точно выраженной форме, в общении соответствует ситуации (3 уровень)
* Организация кода в файле
- Нет чёткой организации кода в файле (0 уровень)
- Методы сгруппированы логически и по вызовам (1 уровень)
- Код разделён на регионы,  имеет хорошие комментарии, в т.ч. со ссылками на другие файлы исходников. (2 уровень)
- Файл имеет разделы "license header", "summary", хорошие комментарии, непротиворечивую расстановку пробелов и табуляции. Файл должен выглядеть красиво. (3 уровень)
* Организация кода между файлами
- Не приходит в голову мысль четко организовать код с помощью разделения на файлы. (0 уровень)
- Похожие файлы группируются в папку. (1 уровень)
- Каждый физический файл предназначен для чего-то одного, например, служит для объявления одного класса или для реализации одного функционала и т.д. (2 уровень)
- Организация кода на физическом уровне точно соответствует проекту. Глядя на имена файлов и структуру папок, можно понять как спроектирована данная реализация. (3 уровень)
* Организация дерева исходников
- Всё в одной папке (0 уровень)
- Простое разделение кода в логические подкаталоги. (1 уровень)
- Нет "круговых" зависимостей. Бинарники, либы, документация, билды, сторонний код - все разложено в соответствующие папки. (2 уровень)
- Структура дерева исходного кода соответствует логической иерархии и организации кода в проекте.
Глядя на имена файлов и структуру папок, можно понять как спроектирована данная система. (3 уровень)
* Читабельность кода
- Односложные имена (0 уровень)
- Хорошие имена файлов, переменных, классов, методов и т.д. (1 уровень)
- Нет длинных функций, а нестандартный код, багфиксы и допущения в коде поясняются комментариями. (2 уровень)
- Допущения в коде сопровождаются assert'ами. Поток операций в коде естественный - нет глубокой вложенности условий или методов. (3 уровень)
* Безопасное программирование
- Не понимает концепцию (0 уровень)
- Проверяет все аргументы и ставит assert'ы на критические допущения в коде. (1 уровень)
- Убеждается, что проверил возвращаемое значение и что обрабатывает исключения в потенциально бажном коде. (2 уровень)
- Имеет свою собственную библиотеку помогающую в безопасном программировании, пишет юнит-тесты которые эмулируют сбои. (3 уровень)
* Обработка ошибок
- Пишет код для "идеального" случая, когда все работает и нет сбоев. (0 уровень)
- Обработка ошибок в коде, который либо кидает исключение, либо генерирует ошибку. (1 уровень)
- Убеждается, что после того, как произошла ошибка/исключение, программа продолжает работать, а ненужные более ресурсы, коннекшоны и память были корректно освобождены обработчиком ошибки. (2 уровень)
- Пишет код так, чтобы определять возможные ошибки на раннем этапе,  придерживается последовательной стратегии обработки исключений во всех слоях кода, разрабатывает общие принципы обработки исключений во всей системе. (3 уровень)
* Системное программирование
- Базовое понимание компиляторов, компоновщиков и интерпретаторов.
Понимание, что такое ассемблерный код и как работают программы на уровне железа. Небольшое понимание виртуальной памяти и пэйджинга. (1 уровень)
- Понимание чем отличается kernel mode от user mode, что такое мульти-трединг (multithreading). Знать способы синхронизации и как реализованы примитивы синхронизации. Умение читать ассемблерный код.Понимание принципов работы сети, сетевых протоколов и умение реализовать передачу данных через сокеты. (2 уровень)
- Понимает принципов работы всего "программного стэка": железо (CPU + Память + Кэш + Прерывания + микрокоды), двоичный код, ассемблер, статическая и динамическая линковка, компиляция, интерпретация, JIT-компиляция, сборка мусора, куча, стэк, адресация памяти. (3 уровень)
* IDEs
- В основном использует IDE для редактирования текста. (0 уровень)
- Способен эффективно пользоваться меню в IDE. Знает некоторые тонкости среды. (1 уровень)
- Для самых используемых функций среды знает горячие клавиши. (2 уровень)
- Пишет свои макросы (3 уровень)
* API
- Часто обращается к документации (0 уровень)
- Помнит наиболее используемые API (1 уровень)
- Обширные и глубокие знания API (2 уровень)
- Пишет библиотеки, которые оборачивают API, для упрощения задач, которые наиболее часто встречаются. Эти библиотеки также часто восполняют пробелы в API. (3 уровень)
* Фреймворки
- Не использует никаких фреймворков за рамками основной платформы (0 уровень)
- Знает, но не использует популярные фреймворки, доступные для его платформы. (1 уровень)
- Профессионально пользовался более чем одним фреймворком и хорошо разбирается в идиомах фреймворков. (2 уровень)
- Является автором фреймворка. (3 уровень)
* Требования
- Понимает выставленные требования и пишет код в соответствии со спецификацией. (0 уровень)
- Задает вопросы касающиеся не рассмотренных в спецификации случаев. (1 уровень)
- Понимает картину в целом и предлагает дополнительные аспекты, которые должны быть описаны в спецификации. (2 уровень)
- Может предложить лучшие альтернативы и следовать выставленным требованиям, основываясь на собственном опыте. (3 уровень)
* Скрипты
- Отсутствует знание скриптовых инструментов. (0 уровень)
- Batch-файлы/shell. (1 уровень)
- Perl/Python/Ruby/VBScript/
Powershell. (2 уровень)
- Писал и публиковал повторно используемые скрипты. (3 уровень)
* Базы данных
- Ограничен excel как базой данных (0 уровень)
- Знает основы БД, нормализацию, ACID, транзакции и может написать простые select'ы (1 уровень)
- Может спроектировать хорошие нормализованные схемы БД, с учетом запросов, которые будут выполняться; умело использует представления, хранимые процедуры, триггеры и собственные типы данных. Понимает разницу между кластеризованными и не-кластеризованными индексами. Специалист в использовании  ORM -тулзов. (2 уровень)
- Может осуществлять администрирование БД, оптимизацию производительности БД, индексную оптимизацию, писать сложные select'ы, может заменить использование курсора  вызовами функций SQL, понимает как данные хранятся внутри, как хранятся индексы, имеет представление о том, как зеркалятся и реплицируются БД и т.д.  Понимает как работает двухфазный commit. (3 уровень)
* Опыт работы на языках программирования
- Императивные [машинный код, ассемблер, Java, Python, JS, C, C++] или ООПшные [C#, C++, Delphi, F#, Java, JS, Kotlin, Perl, PHP, Python, Ruby, Scala, Lua, Crystal, etc.] (0 уровень)
- Императивные, ООПшные и декларативные (SQL, HTML) языки программирования. Дополнительный бонус - если понимает разницу между статической и динамической, слабой и строгой типизацией, 
статически выводимыми типами. (1 уровень)
- Функциональные языки программирования [Lisp, Erlang, Elixir, ML, Scala, Miranda, Nemerle, Haskell]. Дополнительный бонус - если знает, что такое "ленивые вычисления", каррирование, продолжения. (2 уровень)
- Конкурентные 
(Erlang, Oz) и логические (Prolog). (3 уровень)
* Годы профессионального опыта
- 1 год (0 уровень)
- 2-5 лет (1 уровень)
- 6-9 лет (2 уровень)
- 10+ лет (3 уровень)
* Годы профессионального опыта на конкретной платформе
- 1 год (0 уровень)
- 2-3 года (1 уровень)
- 4-5 лет (2 уровень)
- 6+ лет (3 уровень)
* Знания предметной области
- Не знает о понятии "предметная область" (0 уровень)
- Работал хотя бы над одним продуктом в своей предметной области. (1 уровень)
- Работал над несколькими продуктами в одной и той же предметной области. (2 уровень)
- Эксперт своей предметной области, проектировал и реализовывал несколько продуктов/решений в ней, хорошо разбирается в ее сущностях и протоколах. (3 уровень)
* Инструментарии
- Ограничены используемой IDE (VS.Net, Eclipse и т.д.) (0 уровень)
- Знает о некоторых альтернативах популярным стандартным инструментариям. (1 уровень)
- Хорошие знания редакторов кода, отладчиков, различных IDE, open-source альтернативах и т.д. (Например, это может быть кто-то, кто знает большинство тулзов из списка Скота Ганзельмана.)
Использует ORM-тулзы. (2 уровень)
- Написал свои инструментарии и скрипты, дополнительный плюс - если эти скрипты были опубликованы. (3 уровень)
* Кодовая база
- Никогда не смотрел кодовую базу. (0 уровень)
- Имеет общее представление о расположении кода и о том, как его собрать. (1 уровень)
- Хорошие рабочие знания кодовой базы, реализовывал несколько багфиксов и, может быть, некоторые маленькие фичи. (2 уровень)
- Реализовал несколько больших фич в кодовой базе, может легко описать изменения, требуемые для реализации большинства фич или багфисков. (3 уровень)
* Знание новейших технологий
- Не слышал о новейших технологиях. (0 уровень)
- Слышал о новейших технологиях в своей области. (1 уровень)
- Скачивал alpha/preview/CTP
/beta-версии и читал некоторые статьи и руководства на эти темы. (2 уровень)
- Пробовал сделать что-либо сам. Используя preview-версию сбилдил свою программу. Дополнительный плюс - если сделал свое решение доступным для других. (3 уровень)
* Знание внутренних аспектов платформы
- Нулевые знания внутренних аспектов платформы. (0 уровень)
- В основном, знает как работает платформа внутри. (1 уровень)
- Имеет глубокие познания внутренних аспектов платформы и может обрисовать, как платформа исполняет программный код. (2 уровень)
- Написал свои тулзы для расширения возможностей платформы или для извлечения дополнительной информации о работе платформы. Например расширения дизассемблера, декомпилятора, отладчика и т.д. (3 уровень)
* Книги
- Серия книг "для чайников", "C++ за 21 день" и т.п. (0 уровень)
- "Совершенный код" Стива Макконелла, "Не заставляйте меня думать!" Стив Круг, "Регулярные выражения" Фридл Джеффри (1 уровень)
- "Человеческий фактор: успешные проекты и команды" Тома Демарко и Тимоти Листера, "Приемы объектно-ориентиро-ванного проектирования. Паттерны проектирования" Банды четырёх, Эриха Гаммы и пр. "Жемчужины проектирования алгоритмов. Функциональный подход" Ричарда Бёрда, "Алгоритмы. Руководство по разработке" Стивена Скиены, "Программист-прагматик. Путь от подмастерья к мастеру" Эндрю Ханта и Дэвида Томаса, "Мифический человеко-месяц, или как создаются программные системы" Чапела Хилла и Фредерика Брукса (2 уровень)
- "Искусство программирования" Дональда Кнута, "Структура и интерпретация компьютерных программ" Харольда Абельсона и Джеральда Сассмана, "Concepts, Techniques, and Models of Computer Programming" Питеря Роя и Шеифа Хариди, "An Introduction to Database Systems, Eighth Edition" C.J.Date, "Thinking Forth" Leo Brodie, "The Little Schemer - 4th Edition" Daniel P. Friedman (3 уровень)
* Блоги
- Слышал о блогах, но не уделял им внимания. (0 уровень)
- Читает технические блоги, блоги о программировании и разработке ПО и регулярно слушает подкасты. (1 уровень)
- Ведет ссылочный блог, содержащий коллекции  ссылок на полезные статьи и тулзы, которые [ссылки] он собирает. (2 уровень)
- Ведет блог, в котором содержится его собственные понимание вопросов программирования. (3 уровень)
55) Блок "энтерпрайз архитектуры"

56) Облака - IaaS, PaaS, SaaS
57) APIs, REST-сервисы, GraphQL
58) Микросервисная архитектура и монолиты
59) События и потоки событий (стриминговые и событийные архитектуры)
60) Топология, подсистемы балансировки нагрузки
61) Трёхслойная архитектура
62) Сериализация (JSON, XML)
63) Синхронные и асинхронные сообщения
64) Логгирование и мониторинг (Grafana, Pager Duty, New Relic, RunScope, Sentry, Kibana, Data Dog)
65) Enterpise Security
66) Провайдеры облачных решений
- aws (Amazon Web Services)
- gcp (Google Cloud Platforms)
- azure (Microsoft Azure)
67) Сохранение данных, управление кэшем и прокси
68) Репликация данных
69) pubs/subs
70) Блок "основ автоматизации тестирования"

71) testing vs checking
72) Пирамида тестирования
73) Автоматизация тестирования как инвестиция
74) Типы автоматзации
- юнит
- api
- веб
75) automation oracles
76) test data management
77) Фреймворки тестирования
78) mocking, spoofing, stubbing, test doubles
- wiremock
- mountebank
79) low-code automation & no-code automation
80) record & playback
81) bdd-язык gherkin
- cucumber
- specflow
82) visual regression
- applitools
- percy
* Контроль версий исходников
- Бэкап исходников в папку с датой бэкапа. (0 уровень)
- VSS и основы CVS/SVN в качестве пользователя. (1 уровень)
- Уверенные навыки в CVS и SVN. Знать как создать, разветвить, слить репозиторий и т.д. (2 уровень)
- Знает распределенные системы контроля версий. Уметь работать с Mercurial/Darcs/Git (3 уровень)
* Автоматизация билдов
- Знать, как запускать build из среды программирования (0 уровень)
- Уметь билдить из командной строки (1 уровень)
- Уметь настраивать скрипты для сборки основной системы (2 уровень)
- Уметь настраивать скрипт для сборки системы и документации, для сборки инсталляторов. Уметь составлять и добавлять код скрипта в систему контроля версий исходников.
83) Блок "поставки Agile"

84) scrum, kanban, lean
85) estimation techniques
86) agile project management software
- jira
- rally
- MS Project
- Assembla
- YouTrack
- Trello
87) agile ceremonies (стендап, ретро, демо и проч.)
88) stories and ACs (story definition, acceptance criteria definition, story estimation techniques)
89) commercial agile
90) agile in the enterprise (Scaled Agile - SAFe, LeSS, Nexus, etc.)
91) objections to agile
92) Блок "роль и обязанности тестировщика"

93) example approaches
- Microsoft Combined Engineering Approach (https://learn.microsoft.com/en-us/devops/develop/shift-left-make-testing-fast-reliable)
- Atlassian Qality Assistance Model (https://www.atlassian.com/inside-atlassian/qa)
- Spotify Model (https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf)
- Google Model (https://www.amazon.com/Google-Tests-Software-James-Whittaker/dp/0321803027)
- Slalom Build's Quality Engineering Core Principles (https://medium.com/slalom-build/quality-engineering-core-principles-13cbc34bf389)
94) Исторические роли
95) quality gates
96) Quality Assurance (QA: ) vs Quality Control [https://www.guru99.com/all-about-quality-assurance.html]
97) Блок "юнит-тестирование" (оно же "модульное" тестирование, выполняется разрабами, но разбираться в нём нужно и тестерам)

98) TDD для создания тестов
99) functional and OO Unit Testing (разница между юнит-тестами в функциональных и ООП языках)
100) Mocking / Code Isolation
101) Mutation Testing (паттерны, упрощающие тестирование)
102) Language Specific Frameworks
102.1) Java Frameworks
- JUnit
- TestNG
- NUnit
- Mockito
- EasyMock
102.2) JavaScript Frameworks
- Jest
- Jasmine
- Mocha
102.3) Python Frameworks
- PyTest
* Продвинутый уровень - умение создавать автоматические тесты на функционал, пользовательский интерфейс и загрузку/производительность
104) Блок "автоматизация API"

105) Инструменты:
- PostMan
- Fiddler
- Insomnia
- JUnit (тест-раннер) через библиотеку взаимодействия с сервисом по типу HttpClient и т.н. библиотеки матчеров, проверяющей ассерты (Hamcrest)
106) API Test Frameworks
- RestAssured
- Karate
107) API GUI Tools
108) Contract Testing
- Pact.io
- Swagger
109) Тестирование REST-сервисов
110) Тестирование веб-сервисов
111) Тестирование SOAP-сервисов
112) Тестирование запросов в рамках стриминговых архитектур
113) Тестирование файловых интерфейсов
114) Тестирование бинарных протоколов (возможно, но не обязательно)
115) Блок "автоматизация web UI или веб-интерфейсов"

116) Лимиты UI автоматизации
117) codeless / record playback web automation
- Ranorex
- Katalon Studio
- TestComplete
118) headless browsers
119) POM / UI patterns
120) Web UI Frameworks
120.1) Non-Selenium
- Cypress
- Ruppeteer
- Playwright
- Soap UI
- Karateframework
- QA Wolf
- Jasmine
- Nightwatch
- Robot
- Jest
120.2) Selenium Based
120.3) Framework Design
120.4) Selectors
120.5) Web Driver Protocol
- WebDriver / RC
- WebDriver.io
- Protractor
- Watir
- Appium (оболочки и производные Selenium)
121) open-source инструменты для автоматизированного тестирования
122) Блок "непрерывная интеграция, поставка и развёртывание"

123) Branching Strategies
- trunk
- feature
- GitFlow
- GitHubFlow
124) Collaboration, Pull Requests
125) Hosting Platforms
- GitHub
- BitBucket
- AWS CodeCommit
126) Configuration and Build
127) Artifact repos, versioning
128) Контейнеры
- docker
- kubernetes
129) "инфраструктура как код"
130) интеграция с автоматизацией, работа со скриптами в Cloud Formation или тому подобных инструментах
131) feature flags, toggles
132) environments, ephemeral
133) deployment and release
134) remote execution / device farms
- SauceLabs
- BrowserStack
- AWS Device Farm
135) Оркестрация
- Jenkins (написание пайплайнов)
- CircleCI
- AWS CodePipeline
- TeamCity
136) Блок "тестирование производительности"

137) taxonomy
- load
- stress
- soak
- resilency
138) in pipeline
139) in agile
140) Инструменты
- Apache JMeter / Blazemeter
- Artillery
- Gatling
- Locust
141) Блок "тестирование мобильных приложений"

142) native, hybrid, mobile web (нативные приложения, гибридные приложения, мобильные интерфейсы)
143) iOS Specific
- XCUTest
144) Android Specific (между тестированием на android и ios есть существенные различия)
- Espresso
145) Cross-Platform Frameworks
- Xamarin
- React Native
- Titanium
- Appium
146) Distribution & Release
147) Device Farms
148) Emulator vs Simulator
149) Mobile Automation Tools
150) Mobile Specific Testing
- Device Configuration
- Mobile Performance
- Phone and OS Compat
- Connection Testing
- Mobile Security
151) Блок "тестирование доступности" (к слову о людях с ограниченными возможностями)

152) 508 US Accessibility Standards
153) WCAG 2 (Web Content Accessibility Guidelines, созданы Консорциумом W3)
154) Scanning Tools
- Chrome DevTools Audit
- Wave
- SortSite
- Axe
155) Блок "тестирование безопасности"

156) Аутентификация и авторизация
157) Векторы атаки
158) Поверхность атаки
159) Пентесты (тестирование на проникновение)
160) Криптография (в т.ч. открытые ключи)
161) OWASP Top 10 (Open Web Application Security Project, перечень 10 наиболее опасных уязвимостей)
162) Сканеры уязвимостей
163) Управление защищёнными данными (с ограниченным доступом)
164) Блок "тестирование искуственного интеллекта"

165) + over 200 задач только по этой теме
166) Блок "тестирование в машинном обучении"

167) + ещё 300 задач
168) Блок "тестирование в BigData"
169) + ещё много задач :)

Классификация видов тестирования (для общего развития - в дальнейшем добавить в общий пул задач и как-то классифицировать)

1) По запуску кода на исполнение
1.1) Статическое
1.2) Динамическое

2) По уровню детализации приложения (по уровню тестирования)
2.1) Модульное тестирование
2.2) Интеграционное тестирование
2.3) Системное тестирование

3) По фокусировке на уровне архитектуры приложения
3.1) Уровень представления
3.2) Уровень бизнес-логики
3.3) Уровень данных

4) По доступу к коду и архитектуре приложения
4.1) Метод белого ящика
4.2) Метод серого яшика
4.3) Метод чёрного ящика

5) По убыванию степени важности тестируемых функций (по уровню функционального тестирования)
5.1) "Дымовое" (смоук)
5.2) Критического пути
5.3) Расширенное

6) По привлечению конечных пользователей
6.1) Альфа-тестирование
6.2) Бета-тестирование
6.3) Гамма-тестирование

7) По степени автоматизации
7.1) Ручное
7.2) Автоматизированное (и "автоматическое")

8) По природе приложения
8.1) Веб
8.2) Мобильное
8.3) Настольное (десктоп)
8.4) и другие

9) По степени формализации
9.1) На основе тест-кейсов
9.2) Исследовательское
9.3) Свободное (интуитивное)

10) По целям и задачам
10.1) По прицнипам работы с приложением
10.1.1) Позитивное
10.1.2) Негативное
10.2) Удобства использования
10.3) Доступности
10.4) Интерфейса
10.5) Безопасности
10.6) Интернационализации
10.7) Локализации
10.8) Совместимости
10.8.1) Конфигурационное
10.8.2) Кроссбраузерное
10.9) Сравнительное
10.10) Демонстрационное
10.11) Функциональное
10.12) Нефункциональное
10.13) Надёжности
10.14) Восстанавливаемости
10.15) Отказоустойчивости
10.16) Данных и баз данных
10.17) Использования ресурсов
10.18) Производительности
10.18.1) Нагрузочное
10.18.2) Масштабируемости
10.18.3) Объёмное
10.18.4) Стрессовое
10.18.5) Конкурентное
10.19) Инсталяционное
10.20) Регрессионное
10.21) Повторное
10.22) Приёмочное

11) По техникам автоматизации
11.1) Под управлением данными
11.2) Под управлением ключевыми словами
11.3) Под управлением поведением

12) На основе структур кода
12.1) Выражений
12.2) Ветвей
12.3) Условий
12.4) Комбинации условий
12.5) Решений
12.6) Решающих условий
12.7) Путей

13) По техникам и подходам
13.1) Позитивное
13.2) Негативное

13.1.1) На основе опыта тестировщика, сценариев, чек-листов
13.1.1.1) Исследовательское
13.1.1.2) Свободное (интуитивное)

13.2.1) По степени вмешательства в работу приложения
13.2.1.1) Инвазивное
13.2.1.2) Неинвазивное

13.3.1) На основе знания источников ошибок
13.3.1.1) Предугадывание ошибок
13.3.1.2) Эвристическая ошибка
13.3.1.3) Добавление ошибок
13.3.1.4) Мутационное

13.4.1) На основе выбора входных данных
13.4.1.1) На основе классов эквивалентности
13.4.1.2) На основе граничных условий
13.4.1.3) Доменное
13.4.1.4) Попарное
13.4.1.5) На основе ортогональных массивов

13.5.1) На основе среды выполнения
13.5.1.1) Тестирование в процессе разработки
13.5.1.1) Операционное тестирование

13.6.1) На основе кода
13.6.1.1) По потоку управления
13.6.1.2) По потоку данных
13.6.1.3) По диаграмме или таблице состояний
13.6.1.4) Инспекция (аудит) кода

13.7.1) На основе моделей поведения приложения
13.7.1.1) По таблице принятия решений
13.7.1.2) По диаграмме или таблице состояний
13.7.1.3) По спецификациям
13.7.1.4) По моделям поведения приложения
13.7.1.5) На основе вариантов использования
13.7.1.6) Параллельное
13.7.1.7) На основе случайных данных
13.7.1.8) A / B

14) По моменту выполнения (хронологии)
14.1) Общая универсальная логика последовательности тестирования
14.1.1) Позитивное простое
14.1.2) (далее) Негативное простое
14.1.3) (затем) Позитивное сложное
14.1.4) (в завершении) Негативное сложное

14.2) По иерархии компонентов
14.2.1) Восходящее
14.2.2) Нисходящее
14.2.3) Гибридное

14.3) По концентрации внимания на требованиях и их составляющих
14.3.1) Тестирование требований
14.3.2) Тестирование функциональных составляющих
14.3.3) Тестирование нефункциональных составляющих

18) Типичные общие сценарии
18.1) 1-й сценарий
18.1.1) Дымовое ("смоук")
18.1.2) Критического пути
18.1.3) Расширенное

18.2) 2-й сценарий
18.2.1) Модульное тестирование ↔ Гибридное тестирование
18.2.2) Гибридное тестирование ↔ Интеграционное тестирование
18.2.3) Интеграционное тестирование ↔ Гибридное тестирование
18.2.4) Гибридное тестирование ↔ Системное тестирование
18.2.5) Системное тестирование ↔ Гибридное тестирование

18.3) 3-й сценарий
18.3.1) Альфа-тестирование ↔ Приёмочное тестирование
18.3.2) Приёмочное тестирование → Операционное тестирование
18.3.3) Операционное тестирование → Приёмочное тестирование
18.3.4) Приёмочное тестирование ↔ Бета-тестирование
18.3.5) Бета-тестирование ↔ Приёмочное тестирование
18.3.6) Приёмочное тестирование → Операционное тестирование
18.3.7) Операционное тестирование → Приёмочное тестирование
18.3.8) Приёмочное тестирование ↔ Гамма-тестирование
18.3.9) Гамма-тестирование ↔ Приёмочное тестирование
18.3.10) Приёмочное тестирование → Операционное тестирование


Ниже конспект с вебинара о знакомстве со специализациями (path to txt file: D:/1_Аскер/1_Главное/3_ДПО и повышение квалификации/1_GeekBrains/Ручной тестировщик ПО/4_Знакомство со специализациями IT_вебинарный курс/Специализации в IT_конспект видео):


Вне контекста полезная информация:
Информация в любом ПО устроено 3 слоями:
Слой обработки информации
Слой логической проверки информации
Слой интерфейсов

Рассмотрим 5 специализаций: 
* Разработка

Суть работы: написание кода, благодаря которому разрабатываемое ПО обладает нужными функциями и работает исправно.
/ Разработка XRM-систем
/ Веб-разработка
/ Разработка игр
/ Разработка ИИ

Разработка затрагивает работу в таких средах, как: 
/ Android Studio
/ CMS Webflow
/ GitHub
/ IDE Sublime Text 3
/ СУБД MySQL
/ Atom: работа с кодом

Условно грейды (уровни, распределения по профессионализму) можно разделить на 3 ступени: 

/ Junior (опыт работы 0,5 - 1,5 года), младший специалист. Знает основы профессии, способен выполнить несложное ТЗ
// Middle (опыт работы 1,5 - 3 года), специалист среднего уровня. Умеет работать с ТЗ, реализует функционал, понимает задачи проекта
/// Senior (опыт работы 4-6 лет), старший специалист. Определяет способы реализации задачи, отвечает за других специалистов в команде.


По функциональному назначению разработку можно разделить на 3 направления:

/ Frontend
/ Backend
/ Fullstack


Для справки перечень операционных систем: 
› Linux
› Microsoft Windows
› Android
› macOS
› iOS
› AmigaOS
› FreeBSD
› ReactOS
› Plan 9
› Inferno OS
› Menuet OS
› Kolibri OS
› ОС Эльбрус
› BlackBerry OS
› LG web OS
› Облачная Chrome OS
› tv OS
› watch OS
› Haiku
› Solaris
› OpenVMS
› Tizen
› KaiOS


Приблизительный перечень общепринятых и наиболее популярных языков программирования:
# Pascal
# Basic
# PureBasic
# Visual Basic .NET (VB.NET)
# C
# Objective-C
# C++
# C#
# CSS
# HTML
# HTML5
# Fortran
# Assembly language
# AspectJ
# Chef
# Dart
# Delphi
# Elixir
# Erlang
# Genie
# Go
# Groovy
# Haskell
# Java
# JavaScript
# Julia
# Kotlin
# Lisp
# Matlab
# Mercury
# Node.js
# Perl
# PHP
# Python
# R
# React.js
# Ruby
# Rust
# Sass
# Scala
# SQL
# Swift
# TypeScript
# Vala


Около 2 млрд сайтов и около 1 млрд программ разработано на текущий момент во всём мире, на вышеперечисленных языках и т.п.

Написание кода технически не обходится без использования библиотек. Ниже приведён перечень наиболее популярных: 
→ Boost
→ DynaPDF
→ Elgen
→ FL Toolkit
→ GMP
→ Juice
→ libjpg
→ pnglib
→ Rasterbar libtorrent
→ Pcap
→ Open Neural Networks Library
→ Simple and Fast Multimedia Library
→ SDL
→ Apache C++ Standard Library
→ Standard Template Library
→ wxWidgets
→ Android Architecture
→ Components
→ Butterknife
→ Apache Commons CLI
→ Apache Commons CSV
→ Apache Commons Ю
→ Apache Commons Math
→ Google Gson
→ Guava
→ Hibernate-ORM
→ Jhipster
→ Java.sound
→ Java.net
→ Java-Lang
→ Junit
→ LeakCanary
→ Maven
→ Mockito
→ Rest-assured
→ D3
→ jQuery
→ ReactJS
→ Redux
→ Theano
→ Arrow
→ Astropy
→ Genshi
→ Keras
→ Matplotlib
→ NLTK
→ NumPy
→ ONNX
→ Pandas
→ Pillow
→ Pygame
→ PyNGL
→ PyObjC
→ PyGTK
→ PIL
→ Requests
→ Scapy
→ Scikit-learn
→ SciPy
→ SQLAlchemy
→ TensorFlow
→ Tkinter
→ wxPython
→ Стандартная библиотека Python
→ Tk
→ Cairo
→ Check
→ GD
→ Gettext
→ GIMP Toolkit
→ ImageMagick
→ Libcurl
→ Libpq
→ Libusb
→ math.h
→ Ncurses
→ OpenSSL
→ Zippy
→ SQLIte
→ Zbar
→ Zlib
→ Smarty
→ xajax
→ Rmagick
→ Стандартная библиотека Ruby


Код редактируется и создаётся в редакторах кода (средах разработки) и контролируется с помощью систем контроля версий: 

Наиболее популярные редакторы кода (IDE):
∆ Visual Studio Code
∆ Visual Studio
∆ PyCharm
∆ Atom
∆ Sublime Text
∆ Intellij IDEA
∆ Vim
∆ Eclipse
∆ Aptana Studio
∆ Notepad++
∆ Notepadqq
∆ PHPNotepad
∆ GNU Emacs
∆ SpaceMacs
∆ Aquamacs
∆ Xemacs
∆ Komodo Edit
∆ Komodo IDE
∆ PHPStorm
∆ WebStorm
∆ NetBeans
∆ Codeanywhere
∆ Cloud9
∆ Adobe Dreamweaver
∆ CC
∆ CoffeeCup HTML
∆ TextMate
∆ Xcode
∆ Code::Blocks
∆ Codelobster
∆ Aptana Studio 3
∆ Bluefish
∆ CKEditor
∆ CudaText
∆ Textadept
∆ Medit
∆ Gedit
∆ SciTE
∆ CodeRunner
∆ Espresso
∆ RapidWeaver
∆ EmEditor
∆ EmEditor Pro
∆ PSPad


Наиболее популярные системы контроля версий: 
║ Git
║ RCS (revision control system)
║ Subversion (Apache subversion)
║ Monotone
║ Mercurial
║ Bazaar
║ Perforce, Helix, p4, p4d
║ Bitkeeper
║ darcs
║ Rational ClearCase
║ PVCS Version Manager
║ Fossil


В разработке также используется большое количество фреймворков: 
■ Django
■ Symfony
■ Laravel
■ Express.js
■ Ruby on Rails
■ Sinatra
■ AngularJS
■ Angular
■ Vue.js
■ Svelte
■ Yli
■ CodeIgniter
■ CakePHP
■ Phalcon
■ FuelPHP
■ Nette Framework
■ Bootstrap
■ Semantic UI
■ Foundation
■ Flask
■ Web2py
■ TurboGears
■ CherryPy
■ Pyramid
■ Tornado
■ Grok framework
■ Bottle
■ Quixote
■ Twisted
■ Spring
■ Xamarin
■ Meteor
■ Next.js
■ Nuxt
■ Aurella JS
■ qooxdoo
■ Ember.js
■ Flutter
■ lonic
■ NativeScript
■ Neuton AutoML
■ PyTorch
■ Box Skills
■ TensorFlow
■ XGBoost
■ Keras
■ PyTorch


Ну и системы управления базами данных (СУБД), конечно тоже: 
□ Oracle
□ MySQL
□ PostgreSQL
□ MongoDB
□ DB2
□ Microsoft Access
□ Cassandra
□ Redis
□ Elasticsearch
□ SQLite
□ MariaDB
□ Apache Hive
□ Microsoft SQL Server
□ Amazon DynamoDB
□ Neo4j
□ Adaptive Server
□ Enterprise
□ SAP HANA
□ FileMaker
□ Hbase
□ InfluxDB
□ Firebird
□ Apache CouchDB
□ dBASE
□ Greenplum
□ Marklogic Server
□ Amazon Aurora
□ H2


На уровне архитекторов существуют также системы оркестрации, системы контейнеризации и CMS-системы.

Системы оркестрации: 
▪ Azure Kubernetes Service (AKS)
▪ Apache Mesos
▪ OpenShift Container Platform
▪ Kubernetes
▪ Docker Swarm
▪ Rancher
▪ Nomad

Системы контейнеризации:
▬ Solaris Containers (Solaris Zone)
▬ OpenVZ
▬ iCore Virtual Accounts
▬ Imctfy
▬ Linux Containers (LXC)
▬ Parallels Virtuozzo Containers chroot
▬ Linux Vserver
▬ Docker
▬ FreeBSD Jail
▬ Singularity

CMS-системы (Content Management Systems):
▲ WordPress
▲ Joomla!
▲ MODX
▲ Drupal
▲ vBulletin
▲ TYPO3
▲ 1C-Битрикс
▲ OpenCart
▲ Tilda
▲ Wix
▲ Shop-Script
▲ HostCMS
▲ Datalife Engine
▲ UMI.CMS
▲ Amiro.CMS
▲ Webflow


Комбинация инструментов, определяющих программиста:
► Отрасль
► СУБД
► Среда разработки
► Платформа
► Сторона разработки
► Языки программирования
► CMS-системы
► Фреймворки
► ОС
► VCS
► Страна


В разработке нужно: 
● Уметь структурировать информацию
● Любить порядок
● Быть последовательным
● Понимать строение процессов шаг за шагом
● Быть вдумчивым и внимательным к деталям
● Любить прикладные задачи и автоматизацию процессов вокруг себя
● Видеть последовательность в беспорядочном наборе информации
● Уметь выстраивать структуру

На программе разработчик в gb изучают дискретную математику, тестирование, БД, проектирование ПО и процедурное программирование


По данным прогноза Microsoft Data Science за 2020 год ожидается рост вакансий IT специалистов до 190 млн вакансий (речь идёт, судя по всему, о глобальном, не отечественном контексте), из них:
1 млн - защита данных
6 млн - кибербезопасность
20 млн - анализ данных, машинное обучение и ИИ
98 млн - разработка ПО


ПО, по видам и типам условно делится на 3 типа:
/ Desktop
/ Mobile
/ Оборудование


Перечень отраслей, в которых активно используются IT технологии, примерно следующий: 
1) финтех
2) edtech
3) ИИ
4) biotech
5) foodtech
6) machine learning
7) аналитика
8) маркетинг и реклама
9) автомобильные технологии
10) сельское хозяйство и фермерство
11) космические технологии
12) искусство
13) наука
14) ювелирное дело
15) мобильные приложения
16) разработка ПО на заказ
17) big data
18) blockchain
19) бытовая электроника
20) консалтинг
21) компьютеры
22) consumer goods
23) ИБ
24) строительство
25) облачные вычисления
26) медиа
27) доставка
28) беспилотники
29) БД
30) платформы для разработки
31) e-commerce, маркетплейсы
32) аукционы
33) торговые платформы
34) доски объявлений, агрегаторы
35) электронные каталоги
36) энергетика
37) электроника, технологии
38) мероприятия
39) электронное обучение
40) найм персонала, HR
41) фитнес
42) мебель
43) декор
44) разработка игр, игровые технологии
45) дизайн
46) государственные службы
47) генетика
48) геймификация
49) "зелёные" технологии
50) игорная индустрия
51) подарки
52) здоровье и медицина
53) умные дома
54) образ жизни
55) туризм
56) домашние сервисы
57) интернет вещей
58) инфраструктура
59) ювелирная индустрия
60) юриспруденция
61) SaaS
62) тесты и измерения
63) спорт
64) энергосбережение
65) ПО
66) логистика
67) общественные организации
68) horeca
69) аренда
70) компьютерные сети
71) ритейл
72) полезные ископаемые
73) навигация



* Тестирование
Тестировщик проверяет ПО с помощью тестов на предмет ошибок и передаёт результаты разработчикам

Тестирование подразделяется на ручное и автоматизированное: 

◘ Manual QA
◘ Automation QA


Непосредственно формы и методы тестирования представлены ниже "на примере карандаша":
► Compatibility testing. Проверяем, как пишет карандаш на бумаге, картоне, заборе, и т.п. Проверяем, как он затачивается от точилки, ножа и наждачки. Проверяем, как он хранится в пенале, стакане и коробке с карандашами
► Verification. Взять новый карандаш из коробки и проверить, что стержень на месте, резинка прикреплена к правильному концу, карандаш заточен, твёрдость грифеля соответствует маркировке
► Beta Testing. Раздать коллегам по работе, чтобы они дали обратную связь после его использования
► Validation. Достать новый карандаш из коробки и проверить, что он пишет и резинка стирает текст
► Security Testing. Глаз карандашом не выколен? Если съедим карандаш, то не отравимся?
► UI Testing. Проверить, что шрифт на карандаше читаемый. Проверить, что есть название фирмы. Убедиться, в том, что дизайн красив. Цвет резинки соответствует брендбуку.
► Automated Testing. Сделать робота, научить его писать этим карандашом, заточить карандаш на автоматической точилке.
► Entry Point Testing. Пробовать писать заточенным карандашом, пробовать писать старой резинкой.
► Negative Testing. Писать карандашом на стекле. Стирать резинкой текст, написанный ручкой. Пожевать корпус. Пробовать на прочность (карандаш должен выдержать)
► Usability Testing. Удобно писать? Удобно точить? За ухом держится?
► Performance Testing. Исписать карандашом весь блокнот, проверить хватит ли грифеля. Заточить карандаш 30 раз, проверить, выдержит ли он.
► Black Box Testing. Устройство карандаша неизвестно, пробуем писать на чём попало, исследуем его возможности.
► Functional Testing. Проверить, что карандаш пишет. Проверить, что написанное можно стереть резинкой. Проверить, что карандаш можно заточить.
► Component Testing. Собрать карандаш из запчастей. Проверить, что он пишет и всё надёжно держится.
► Stress Testing. Писать карандашом, сильно на него надавливая. Писать очень много и очень быстро. Разрисовать весь лист A4 (или A3), карандаш должен выдержать.
► Documentation Testing. Проверить инструкцию по использованию карандаша.
► Component Testing. Отдельно точим грифель. Отдельно точим деревяшку. Отдельно стираем резинкой.


Примеры задач тестировщиков: 
1) Тестирование продукта
1.1) Поиск ошибок в продукте, гипотезе, оборудовании
1.2) Разработка методов тестирования
1.3) Написание сценариев тестирования
1.4) Реализация сценариев тестирования
1.5) A/B тестирование (тестирование продуктовой гипотезы, когда часть контента показывается только определённой аудитории)
1.6) Проведение опроса
1.7) Стресс-тест видеокарты (проверка работоспособности и температурного максимума видеокарты)

2) Документирование ошибок, передача данных об ошибках

3) Классификация ошибок и добавление их в БД.


В тестировании нужно:
◊ Нравится выискивать ошибки и уязвимости
◊ Интересно смотреть на IT-продукт со всех сторон
◊ Интересно продумывать сценарии пользователя
◊ Нравится улучшать продукт своими руками
◊ Интересно погружаться в продукты и изучать их изнутри
◊ Аналитический склад ума
◊ Усидчивость и внимательность
◊ Системный подход к решению проблем
◊ Интересно смотреть на одно ПО с разных точек зрения
◊ Любопытство
◊ Смотреть на работу критично


Что входит в программу обучения тестированию в gb:
♦ Ручное и авто тестирование
♦ Локализации дефектов
♦ Тестирование веб-приложений
♦ Тест-кейсы
♦ Тест-менеджмент
♦ Тест-аналитика
♦ Linux
♦ CSS
♦ HTML
♦ SQL
♦ Java


Что можно тестировать:
- Оборудование
- Процессы
- Программы и приложения
- Мнения с помощью опросов
- и т.д. и т.п.

Тестировщики используют следующие инструменты:
¬ Allure - отчёты, автотесты и их аналитика
¬ Git - контроль версий
¬ Selenium - для автоматизаци действий веб-браузера
¬ Linux OS - бесплатная ОС с открытым исходным кодом


* Аналитика

Собирает и обрабатывает информацию, формирует отчёты и помогает бизнесу принимать взвешенные решения. 

Аналитика условно делится по видам и типам вот так:
* ETL-аналитик (extract, transfer & load)
* BI-аналитик
* Аналитик Big Data
* Data инженер
* ETL-разработчик (далее идёт ветвление в business intelligence аналитику и "витрины данных" или аналитические панели)
* Архитектор данных
* ИИ (пересечение с программированием)
* Data Science (пересечение с программированием)
* Machine Learning (пересечение с программированием)
* Нейронные сети (пересечение с программированием)


Среды задач в аналитике:
- Визуализация данных в Power BI
- Работа с БД и создание запросов в SQL
- Создание инфраструктуры хранения данных
- Подготовка различных отчётов


В аналитике нужно:
╬ Критическое мышление
╬ Замечать ошибки других
╬ Уметь и любить работать с большими объёмами информации
╬ Искать закономерности
╬ Анализ задачи перед тем, как взяться за неё
╬ Внимательность к мелочам
╬ Уметь достать суть из большого объёма информации
╬ Способность сделать убедительный вывод на основе анализа



* Проджект-менеджмент

Проджект-менеджер организует задачи и аспекты, касающиеся рабочего процесса

Под "проджектом" в зависимости от контекста, понимают следующее:
¤ Менеджер в IT (создаёт IT продукты)
¤ Общий менеджер (выполняет основные задачи компании)
¤ Проектный менеджер (обеспечивает результаты и качество конкретного проекта)

В digital руководят проектами из таких сфер, как:
» интерактивные экраны
» оффлайн-магазины
» игровые консоли
» цифровое tv
» веб-сайты
» локальные сети
» социальные сети
» смартфоны
» мобильные приложения
» digital гаджеты
» digital art
» компьютеры и планшеты
» pos-терминалы
» терминалы самообслуживания


пмы активно используют таск-трекеры (типа Jira, Slack, Мегаплан, Microsoft Project)

и crm системы наряду с системами аналитики - amoCRM, SAP CRM, Google Analytics, AppMetrica, Yandex Metrica, Мегаплан, Битрикс24 и пр.


проджект решает примерно такие задачи:
Ѻ регулярное планирование, оценка и согласование задач
Ѻ приводит стоимость и сроки изменений разумными
Ѻ достигает цели проекта в установленные сроки и в рамках ресурсов
Ѻ доносит до разработки продуктовую цель
Ѻ помогает сформировать у заказчика реалистичные ожидания
Ѻ устраняет конфликт ожиданий между бизнес-заказчиком и программистом
Ѻ ведёт проекты с учётом времени, задач, приоритетов и ресурсов
Ѻ задаёт руководящий вектор проекту и проектному офису
Ѻ определяет приоритеты по задачам
Ѻ прорабатывает список задач с проектной командой
Ѻ ставит задачи другим сотрудникам в команде
Ѻ уточняет и согласовывает требования
Ѻ контролирует исполнение
Ѻ несёт ответственность за результат
Ѻ работает с изменениями и рисками
Ѻ готовит набор документов по стандартам
Ѻ формирует отчёты для заказчика


пм должен быть:
֍ общительным и расположенным к диалогам
֍ отличным переговорщиком
֍ мыслить системно
֍ любить играть стратегически
֍ организаторские способности
֍ интересно ставить задачи и контролировать их исполнение
֍ любить управление людьми и уметь брать ответственность за команду (команды)


проджекты на курсе gb изучают: 
- управление командой и стандарты менеджмента
- основы программирования и веб-программирование
- составление проектной документации
- контроль версий



* Продакт-менеджмент

продакт администрирует процесс создания продукта от генерации идеи до её реализации и выхода на рынок.

примерный перечень задач продакта: 
۩ анализ рынка
۩ анализ конкурентов
۩ управление ценностью продукта (улучшение продукта, чтобы подороже его продать и увеличить прибыль)
۩ управление жизненным циклом продукта
۩ развитие каналов продаж
۩ анализ эффективности внедрений
۩ управление командой (критический взгляд и применение методологий гибкой разработки в работе разработчиков и дизайнеров)
۩ управление финансовыми ресурсами
۩ разработка стратегии управления продуктом


проджекты это люди, которые: 
• хотят создавать it продукты от идеи до запуска
• умеют смотреть на продукт глазами клиента
• легко идут на контакт с людьми
• обладают аналитическим мышлением
• постановка и задач и контроль их выполнения им нравится
• хотят развивать креативные идеи
• интересно исследовать рынок и работу конкурентов


проджекты на курсе gb изучают: 
℗ unit-экономика
℗ привлечение инвестиций и финансы
℗ бизнес-кейсы
℗ просчёт бизнес-моделей
℗ аналитика
℗ тестирование гипотез
℗ управление командой и основы программирования
