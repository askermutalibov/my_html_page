Студенты должны решить кейс и прикрепить решение к семинару. Преподаватель проверяет его и даёт обратную связь комментариями. Обсуждение прошлого ДЗ на следующем семинаре не предполагается.

Кейс:
Вы хотите стать программистом или управленцем и, возможно, получить позицию Project Manager IT-проектов. Это очень престижно, востребовано и неплохо оплачивается.

Вы в начале обучения и пока не знаете, какое направление выбрать: есть frontend, backend и fullstack-разработка, различные языки программирования и целая область управления IT-проектами.

Нужно начинать обучение и двигаться к своей цели — получить работу в IT. Вы решили гибко подойти к этому вопросу и выбрали Agile-подход. Опишите, как вы построите своё обучение и старт в карьере.


Задание уже просрочено, форму для загрузки открыть не смогут (новые правила geekbrains)

В целом из тех книг и заметок, что я себе сохранил, уже есть хорошие материалы для планирования карьеры тестировщиком (но не проджектом, как в этом задании, если честно).

Немного переформулирую задание и построю примерный (гибкий, агиле) план по старту карьеры в тестировании (QA)

0) Свободное владение основными офисными программами (Microsoft Office 365)
1) Свободное владение ПК на уровне уверенного пользователя (умение устаналивать и настраивать ОС, необходимое ПО)
1.1) "Tester Mindset" [https://softwaretester.careers/the-software-testers-mindset/] + [https://medium.com/@blakenorrish/how-to-think-like-a-tester-7a174ff6aeaf]
2) Сформированное представление о работе тестировщика и желание заниматься именно этой работой [https://www.ministryoftesting.com/dojo/lessons/what-do-software-testers-do-version-0-1]
3) Знание английского языка на уровне беглого чтения англоязычной документации (B1 - B2)

Этот вводный этап может занять примерно 12-18 месяцев.

4) Рекомендованные книги
4.1) "Тестирование dot com" Роман Савин
4.2) "Тестирование программного обеспечения" Святослав Куликов
4.3) "Agile тестирование" Лайзы Криспин и Джанет Грегори
4.4) "PostgreSQL, основы языка SQL" Е.П. Моргунова

5) Освоение функционального тестирования (ниже будут подзадачи этого блока)
6) Научиться читать специальную литературу (и техническую документацию)
7) Научиться планировать своё рабочее время
8) Затем научиться планировать тестирование документации и требований
9) Далее научиться работать с системами управления требованиями
10) Освоить виды тестирования
11) Начать осваивать разработку тестов и тестовых сценариев
12) Научиться работать с системами управления тестами
13) Освоить методы и методологии тестирования (см. фото в папке с полезными материалами по IT)
14) Научиться искать и документировать дефекты
15) Научиться работать с баг-трекинговыми системами
16) Научиться составлять и предоставлять отчёты о результатах тестирования и их отдельные фрагменты (+ коммуникативные навыки)
17) Перейти в область функционального и доменного тестирования
18) Освоить оценку трудозатрат
19) Перейти в область тестирования веб-приложений
20) Освоить интернет-технологии
21) Освоить базы данных и язык SQL, научиться писать простые запросы (для тренировки sqlzoo.net)
22) Научиться работать в различных ОС, в том числе ОС семейства Windows и *nix
23) Научиться создавать хорошие чек-листы
24) Научиться использовать вспомогательные инструментальные средства
25) Понимать методы и виды тестирования, уметь применять их адекватно ситуации
26) Уметь вести деловое общение "очно" и опосредованно через почту и иные способы
27) Понимать принципы работы компьютерных сетей (CS50 гарвардский и любые другие курсы)

Этап изучения функционального тестирования занимает от 6 до 12 месяцев.
Здесь наступает момент выбора: выполнять задачи специалиста по функциональному тестированию, переключиться на бизнес-анализ или на автоматизированное тестирование

28) Траектория бизнес-аналитика

28.1) Проектная работа
28.2) Дальнейшее развитие и/или специализация
28.3) Опытный специалист
28.3.1) Менеджер проектов
28.3.2) Управление ресурсами (мб Team Lead)
28.4) Эксперт → разработка решений

29) Траектория автоматизированного тестирования

29.1) Изучить основы автоматизированного тестирования
29.2) Изучить инструменты и языки программирования java, c#, python, javascript, vbscript, ruby, scala, 4test, jscript, xml, html, wsdl, soap, sql
29.3) Изучить инструменты модульного тестирования: TestNG, JUnit, JMock, NUnit
29.4) Изучить инструменты тестирования настольных приложений: SilikTest, QTP, AutoIt, TestComplete
29.5) Изучить инструменты тестирования веб-приложений и веб-сервисов: Selenium IDE, Selenium Web Driver, Selenium RC & Grid, SOAP UI, HtmlUnit, Jaxb & Jax-ws
29.6) Изучить инструменты тестирования мобильных приложений: Selenium Android Driver, Selenium iOS Driver
29.7) Перейти к специальным технологиям и инструментам: BDD, DDT, TDD, Cucumber, jBehave
29.8) Научиться программировать на уровне, достаточном для создания автоматизированных тестов
29.9) Понимать специфические технологии и инструментальные средства, уметь выбирать и применять их для решения поставленной задачи
29.10) Уверенно понимать принципы работы программных средств
29.11) Уметь планировать, реализовывать и оценивать результаты экспериментов
29.12) Уметь оптимизировать тесты и тестовые сценарии
29.13) Уметь использовать вспомогательные программные средства, используемые проектной командой для автоматизации повседневных задач
29.14) Понимать и уметь использовать несколько высокоуровневых языков программирования, языков и технологий вёрстки (на уровне написания элементарных приложений)

Этап изучения автоматизации тестирования занимает от 6 до 18 месяцев. К этому моменту уже необходимо разбираться в функциональном тестировании, обладать уверенными знаниями в программировании. Автоматизация тестирования = программирование как повседневная деятельность.

30) Освоить ООП (проверочное задание - написать программу по типу Elastic Nodes: https://www.youtube.com/watch?v=I0n07iuowvY)
31) Освоить структуры данных и алгоритмы (дерево, стек, очереди, хеш, теория графов, быстрая сортировка и пр.) (для проверки: https://robocode.sourceforge.io/)
32) "Библия QA": https://github.com/VladislavEremeev/QA_bible
33) Изучить технологию REST (https://habr.com/ru/post/483202/) и (restcountries.eu)
34) Изучить Postman
35) Курс по системам учёта, таск-трекерам, баг-трекерам: https://stepik.org/course/10425/promo (по Jira)
36) Для ведения тест-кейсов, планов и сценариев: https://coderlessons.com/tutorials/kachestvo-programmnogo-obespecheniia/izuchite-testlink/testlink-kratkoe-rukovodstvo (TestLink)
37) Платный курс от Otus по ручному тестированию: https://otus.ru/online/manualtesting/
38) Мониторить материалы не только на Хабре, но и с конференций HeizenBug тоже
39) Завести профиль на LinkedIn, следить там за вакансиями, обновлять резюме, следить за другими специалистами, их наполнением профиля, идти по их следам, чтобы быть в теме.
40) ISTQB сертификация - может что-то значить для джуна


Дорожная карта тестировщика с сайта testengineer (roadmap v. 1.1.1) (https://testengineer.ru/razvitie-testirovshchika/):
1) Блок "базы тестирования"

2) test discovery techniques
- классы эквивалентности
- анализ граничных значений
- use cases
- комбинаторный анализ данных
- exhausive search
3) Приоретизация тестирования (риск-ориентированное тестирование)
4) test taxonomy (test approaches)
- black, white, grey (тестирование методом белого/чёрного/серого ящиков)
- functional, non-functional (функциональное/нефункциональное тестирование) 
[нефункциональное тестирование  касается производительности, безопасности, удобства пользования, совместимости, локализации и т.п.]
- smoke, sanity, acceptance, regression, chaos
- negative and positive (сценарии тестирования)
- unit, integration, e2e
- static vs dynamic
5) sctructured exploratory testing
6) defects and defect management
7) test documentation: test cases, test plans, test case management
- zephyr
- testrail
- qTest
- testlink (это инструменты управления тест-кейсами)
- jira (инструмент управления проектами)
8) STLC
9) test oracles
10) non-functional testing
- performance
- load (Lighthouse, Webpage Test, Gatling, K6, Artillery, Vegeta, JMeter, Locust - инструменты load и performance тестов)
- security
- accessibility (Wave, Axe, Chrome DevTools)
- compatibility
- stress
localization/internationalization
11) production readiness
- UAT
- alpha/beta testing
12) shift left and defect cost
13) quality metrics and reports
14) Блок "основы циклов разработки ПО"

15) Исторически возникшие методы разработки (V-образная, спиральная и пр.)
16) Роли и ответственность участников
17) Agile vs Waterfall
18) Agile Flavors
- Scrum
- Kanban
- SAFe
19) project risks, failure modes
20) Блок "основы работы сети Интернет"

21) Принципы работы сетей
22) OSI модель
23) Архитектура интернета и протоколы
- TCP/IP протокол
- DNS протокол
- HTTP/HTTPS протокол
24) Блок "основы computer science"

25) computer hardware (железо) и принципы управления железом операционной системой и пользовательскими программами
26) Виды (типы) представления данных
- binary
- text: json, xml, yaml
27) языки программирования
- высокоуровневые и низкоуровневые
- компилируемые и интерпретируемые
- функциональные, процедурные, ООПшные и т.п.
28) типы систем
- динамические и статические
- сильные и слабые
29) Алгоритмы и сложность их применения (начиная с простых алгоритмов, заканчивая сложными)
- Знать базовые методы сортировки и поиска, обхода и поиска в структурах данных (1 уровень)
- Деревья, Графы, "простой путь" и  "разделяй и властвуй"-алгоритмы. Понимать ассоциацию уровней этой матрицы. (2 уровень)
- Уметь распознавать и составлять решения динамическим программированием, уверенно знать алгоритмы на графах, отлично разбираться в численных методах, уметь идентифицировать проблемы класа NP (3 уровень)
30) Структуры данных и анализ данных
- Уметь объяснять и использовать на практике массивы, связные списки, словари и пр. (1 уровень)
- Понимать плюсы и минусы использования тех или иных базовых структур данных (размер памяти, время выполнения операций с данными, понимать разницу между массивами и связными списками в этом плане).
Понимать как реализовать хэш-таблицы и как обработать коллизии. Приоритетные очереди и способы их реализации, и т.д. (2 уровень)
- Знать сложные структуры данных (B-дерево, Биномиальная куча и Фибоначчиевская куча, АВЛ-дерево, Красно-чёрное дерево, Косое дерево, Список с пропусками, TRIE-структуры и т.д.)
31) Параллелизм и многопоточность 
32) Операционные системы
33) Блок "основы веб-приложений"

34) Веб-технологии: HTML, CSS, JS (как они работают в браузере, т.е. как он отрисовывает интефейсы)
35) Веб-браузеры
36) AJAX
37) Template Engines
38) SPAs (одностраничные приложения)
39) PWAs (приложения с подгружаемым контентом)
40) JAMStack
41) Криптография
42) CMSs (системы управления контентом)
43) Отрисовка в приложениях и на серверах
44) Адаптивные и реактивные приложения
45) Для практики создать веб-приложение с нуля в разных фреймворках (Angular, React)
46) Разобраться в "тестировании под капотом" (например, с наброском дата-модели и тестирования интерфейса с последующими юнит-тестами или в т.н. headless-браузере: Zombie.js, Playwright, Puppeteer, Cypress, Headless Chrome, Headless Fox, HTML Unit).
47) Блок "основы программирования"

48) Работа в командных строках и оболочках
- bash
- powershell
49) Редакторы и IDE
- Visual Studio
- VS Code
- Sublime
- Intellij
- others
50) Синтаксис языка, операторы, стиль
51) Паттерны проектирования (dry, solid и пр.)
52) Функциональное программирование
- "чистые функции"
- неизменяемые данные
- functional composition
53) Объектно-ориентированное программирование (JavaScript, TypeScript, Java, C#, Python)
- наследование
- полиморфизм
- инкапсуляция
54) Git (ясное дело)
* Декомпозиция задачи
- Процедурный подход, просто последовательные строчки, copy/paste для повторного использования кода (0 уровень)
- Умение разбивать задачу на несколько функций (методов) (1 уровень)
- Умение создавать многократно используемые функции/объекты, которые решают общие задачи (2 уровень)
- Умение использовать соответствующие структуры данных и алгоритмы, создавать общий/объектно-ориентированный код, инкапсулирующий условия задачи, которые могут быть изменены (3 уровень)
* Декомпозиция системы
- Не способен думать о системе более сложной, чем 1 класс или файл (0 уровень)
- Уметь произвести декомпозицию задачи и спроектировать систему в пределах одной платформы или технологии. (1 уровень)
- Уметь проектировать системы, которые охватывают несколько технологий/платформ. (2 уровень)
- Умение визуализировать и проектировать сложные системы с несколькими линейками продуктов, учитывать интеграцию с внешними системами. Умение проектировать системы поддержки работы: мониторинг, генерация отчетов, аварийные переходы на использование запасных ресурсов. (3 уровень)
* Коммуникативные навыки
- Не может выразить свои мысли/идеи, проблемы с правописанием, грамматикой, команда не понимает человека (0 уровень)
- Команда понимает сотрудника, правописание и грамматика хорошие (1 уровень)
- Умеет эффективно общаться (2 уровень)
- Понимает и может объяснить мысли/дизайн/идеи/специфику в точно выраженной форме, в общении соответствует ситуации (3 уровень)
* Организация кода в файле
- Нет чёткой организации кода в файле (0 уровень)
- Методы сгруппированы логически и по вызовам (1 уровень)
- Код разделён на регионы,  имеет хорошие комментарии, в т.ч. со ссылками на другие файлы исходников. (2 уровень)
- Файл имеет разделы "license header", "summary", хорошие комментарии, непротиворечивую расстановку пробелов и табуляции. Файл должен выглядеть красиво. (3 уровень)
* Организация кода между файлами
- Не приходит в голову мысль четко организовать код с помощью разделения на файлы. (0 уровень)
- Похожие файлы группируются в папку. (1 уровень)
- Каждый физический файл предназначен для чего-то одного, например, служит для объявления одного класса или для реализации одного функционала и т.д. (2 уровень)
- Организация кода на физическом уровне точно соответствует проекту. Глядя на имена файлов и структуру папок, можно понять как спроектирована данная реализация. (3 уровень)
* Организация дерева исходников
- Всё в одной папке (0 уровень)
- Простое разделение кода в логические подкаталоги. (1 уровень)
- Нет "круговых" зависимостей. Бинарники, либы, документация, билды, сторонний код - все разложено в соответствующие папки. (2 уровень)
- Структура дерева исходного кода соответствует логической иерархии и организации кода в проекте.
Глядя на имена файлов и структуру папок, можно понять как спроектирована данная система. (3 уровень)
* Читабельность кода
- Односложные имена (0 уровень)
- Хорошие имена файлов, переменных, классов, методов и т.д. (1 уровень)
- Нет длинных функций, а нестандартный код, багфиксы и допущения в коде поясняются комментариями. (2 уровень)
- Допущения в коде сопровождаются assert'ами. Поток операций в коде естественный - нет глубокой вложенности условий или методов. (3 уровень)
* Безопасное программирование
- Не понимает концепцию (0 уровень)
- Проверяет все аргументы и ставит assert'ы на критические допущения в коде. (1 уровень)
- Убеждается, что проверил возвращаемое значение и что обрабатывает исключения в потенциально бажном коде. (2 уровень)
- Имеет свою собственную библиотеку помогающую в безопасном программировании, пишет юнит-тесты которые эмулируют сбои. (3 уровень)
* Обработка ошибок
- Пишет код для "идеального" случая, когда все работает и нет сбоев. (0 уровень)
- Обработка ошибок в коде, который либо кидает исключение, либо генерирует ошибку. (1 уровень)
- Убеждается, что после того, как произошла ошибка/исключение, программа продолжает работать, а ненужные более ресурсы, коннекшоны и память были корректно освобождены обработчиком ошибки. (2 уровень)
- Пишет код так, чтобы определять возможные ошибки на раннем этапе,  придерживается последовательной стратегии обработки исключений во всех слоях кода, разрабатывает общие принципы обработки исключений во всей системе. (3 уровень)
* Системное программирование
- Базовое понимание компиляторов, компоновщиков и интерпретаторов.
Понимание, что такое ассемблерный код и как работают программы на уровне железа. Небольшое понимание виртуальной памяти и пэйджинга. (1 уровень)
- Понимание чем отличается kernel mode от user mode, что такое мульти-трединг (multithreading). Знать способы синхронизации и как реализованы примитивы синхронизации. Умение читать ассемблерный код.Понимание принципов работы сети, сетевых протоколов и умение реализовать передачу данных через сокеты. (2 уровень)
- Понимает принципов работы всего "программного стэка": железо (CPU + Память + Кэш + Прерывания + микрокоды), двоичный код, ассемблер, статическая и динамическая линковка, компиляция, интерпретация, JIT-компиляция, сборка мусора, куча, стэк, адресация памяти. (3 уровень)
* IDEs
- В основном использует IDE для редактирования текста. (0 уровень)
- Способен эффективно пользоваться меню в IDE. Знает некоторые тонкости среды. (1 уровень)
- Для самых используемых функций среды знает горячие клавиши. (2 уровень)
- Пишет свои макросы (3 уровень)
* API
- Часто обращается к документации (0 уровень)
- Помнит наиболее используемые API (1 уровень)
- Обширные и глубокие знания API (2 уровень)
- Пишет библиотеки, которые оборачивают API, для упрощения задач, которые наиболее часто встречаются. Эти библиотеки также часто восполняют пробелы в API. (3 уровень)
* Фреймворки
- Не использует никаких фреймворков за рамками основной платформы (0 уровень)
- Знает, но не использует популярные фреймворки, доступные для его платформы. (1 уровень)
- Профессионально пользовался более чем одним фреймворком и хорошо разбирается в идиомах фреймворков. (2 уровень)
- Является автором фреймворка. (3 уровень)
* Требования
- Понимает выставленные требования и пишет код в соответствии со спецификацией. (0 уровень)
- Задает вопросы касающиеся не рассмотренных в спецификации случаев. (1 уровень)
- Понимает картину в целом и предлагает дополнительные аспекты, которые должны быть описаны в спецификации. (2 уровень)
- Может предложить лучшие альтернативы и следовать выставленным требованиям, основываясь на собственном опыте. (3 уровень)
* Скрипты
- Отсутствует знание скриптовых инструментов. (0 уровень)
- Batch-файлы/shell. (1 уровень)
- Perl/Python/Ruby/VBScript/
Powershell. (2 уровень)
- Писал и публиковал повторно используемые скрипты. (3 уровень)
* Базы данных
- Ограничен excel как базой данных (0 уровень)
- Знает основы БД, нормализацию, ACID, транзакции и может написать простые select'ы (1 уровень)
- Может спроектировать хорошие нормализованные схемы БД, с учетом запросов, которые будут выполняться; умело использует представления, хранимые процедуры, триггеры и собственные типы данных. Понимает разницу между кластеризованными и не-кластеризованными индексами. Специалист в использовании  ORM -тулзов. (2 уровень)
- Может осуществлять администрирование БД, оптимизацию производительности БД, индексную оптимизацию, писать сложные select'ы, может заменить использование курсора  вызовами функций SQL, понимает как данные хранятся внутри, как хранятся индексы, имеет представление о том, как зеркалятся и реплицируются БД и т.д.  Понимает как работает двухфазный commit. (3 уровень)
* Опыт работы на языках программирования
- Императивные [машинный код, ассемблер, Java, Python, JS, C, C++] или ООПшные [C#, C++, Delphi, F#, Java, JS, Kotlin, Perl, PHP, Python, Ruby, Scala, Lua, Crystal, etc.] (0 уровень)
- Императивные, ООПшные и декларативные (SQL, HTML) языки программирования. Дополнительный бонус - если понимает разницу между статической и динамической, слабой и строгой типизацией, 
статически выводимыми типами. (1 уровень)
- Функциональные языки программирования [Lisp, Erlang, Elixir, ML, Scala, Miranda, Nemerle, Haskell]. Дополнительный бонус - если знает, что такое "ленивые вычисления", каррирование, продолжения. (2 уровень)
- Конкурентные 
(Erlang, Oz) и логические (Prolog). (3 уровень)
* Годы профессионального опыта
- 1 год (0 уровень)
- 2-5 лет (1 уровень)
- 6-9 лет (2 уровень)
- 10+ лет (3 уровень)
* Годы профессионального опыта на конкретной платформе
- 1 год (0 уровень)
- 2-3 года (1 уровень)
- 4-5 лет (2 уровень)
- 6+ лет (3 уровень)
* Знания предметной области
- Не знает о понятии "предметная область" (0 уровень)
- Работал хотя бы над одним продуктом в своей предметной области. (1 уровень)
- Работал над несколькими продуктами в одной и той же предметной области. (2 уровень)
- Эксперт своей предметной области, проектировал и реализовывал несколько продуктов/решений в ней, хорошо разбирается в ее сущностях и протоколах. (3 уровень)
* Инструментарии
- Ограничены используемой IDE (VS.Net, Eclipse и т.д.) (0 уровень)
- Знает о некоторых альтернативах популярным стандартным инструментариям. (1 уровень)
- Хорошие знания редакторов кода, отладчиков, различных IDE, open-source альтернативах и т.д. (Например, это может быть кто-то, кто знает большинство тулзов из списка Скота Ганзельмана.)
Использует ORM-тулзы. (2 уровень)
- Написал свои инструментарии и скрипты, дополнительный плюс - если эти скрипты были опубликованы. (3 уровень)
* Кодовая база
- Никогда не смотрел кодовую базу. (0 уровень)
- Имеет общее представление о расположении кода и о том, как его собрать. (1 уровень)
- Хорошие рабочие знания кодовой базы, реализовывал несколько багфиксов и, может быть, некоторые маленькие фичи. (2 уровень)
- Реализовал несколько больших фич в кодовой базе, может легко описать изменения, требуемые для реализации большинства фич или багфисков. (3 уровень)
* Знание новейших технологий
- Не слышал о новейших технологиях. (0 уровень)
- Слышал о новейших технологиях в своей области. (1 уровень)
- Скачивал alpha/preview/CTP
/beta-версии и читал некоторые статьи и руководства на эти темы. (2 уровень)
- Пробовал сделать что-либо сам. Используя preview-версию сбилдил свою программу. Дополнительный плюс - если сделал свое решение доступным для других. (3 уровень)
* Знание внутренних аспектов платформы
- Нулевые знания внутренних аспектов платформы. (0 уровень)
- В основном, знает как работает платформа внутри. (1 уровень)
- Имеет глубокие познания внутренних аспектов платформы и может обрисовать, как платформа исполняет программный код. (2 уровень)
- Написал свои тулзы для расширения возможностей платформы или для извлечения дополнительной информации о работе платформы. Например расширения дизассемблера, декомпилятора, отладчика и т.д. (3 уровень)
* Книги
- Серия книг "для чайников", "C++ за 21 день" и т.п. (0 уровень)
- "Совершенный код" Стива Макконелла, "Не заставляйте меня думать!" Стив Круг, "Регулярные выражения" Фридл Джеффри (1 уровень)
- "Человеческий фактор: успешные проекты и команды" Тома Демарко и Тимоти Листера, "Приемы объектно-ориентиро-ванного проектирования. Паттерны проектирования" Банды четырёх, Эриха Гаммы и пр. "Жемчужины проектирования алгоритмов. Функциональный подход" Ричарда Бёрда, "Алгоритмы. Руководство по разработке" Стивена Скиены, "Программист-прагматик. Путь от подмастерья к мастеру" Эндрю Ханта и Дэвида Томаса, "Мифический человеко-месяц, или как создаются программные системы" Чапела Хилла и Фредерика Брукса (2 уровень)
- "Искусство программирования" Дональда Кнута, "Структура и интерпретация компьютерных программ" Харольда Абельсона и Джеральда Сассмана, "Concepts, Techniques, and Models of Computer Programming" Питеря Роя и Шеифа Хариди, "An Introduction to Database Systems, Eighth Edition" C.J.Date, "Thinking Forth" Leo Brodie, "The Little Schemer - 4th Edition" Daniel P. Friedman (3 уровень)
* Блоги
- Слышал о блогах, но не уделял им внимания. (0 уровень)
- Читает технические блоги, блоги о программировании и разработке ПО и регулярно слушает подкасты. (1 уровень)
- Ведет ссылочный блог, содержащий коллекции  ссылок на полезные статьи и тулзы, которые [ссылки] он собирает. (2 уровень)
- Ведет блог, в котором содержится его собственные понимание вопросов программирования. (3 уровень)
55) Блок "энтерпрайз архитектуры"

56) Облака - IaaS, PaaS, SaaS
57) APIs, REST-сервисы, GraphQL
58) Микросервисная архитектура и монолиты
59) События и потоки событий (стриминговые и событийные архитектуры)
60) Топология, подсистемы балансировки нагрузки
61) Трёхслойная архитектура
62) Сериализация (JSON, XML)
63) Синхронные и асинхронные сообщения
64) Логгирование и мониторинг (Grafana, Pager Duty, New Relic, RunScope, Sentry, Kibana, Data Dog)
65) Enterpise Security
66) Провайдеры облачных решений
- aws (Amazon Web Services)
- gcp (Google Cloud Platforms)
- azure (Microsoft Azure)
67) Сохранение данных, управление кэшем и прокси
68) Репликация данных
69) pubs/subs
70) Блок "основ автоматизации тестирования"

71) testing vs checking
72) Пирамида тестирования
73) Автоматизация тестирования как инвестиция
74) Типы автоматзации
- юнит
- api
- веб
75) automation oracles
76) test data management
77) Фреймворки тестирования
78) mocking, spoofing, stubbing, test doubles
- wiremock
- mountebank
79) low-code automation & no-code automation
80) record & playback
81) bdd-язык gherkin
- cucumber
- specflow
82) visual regression
- applitools
- percy
* Контроль версий исходников
- Бэкап исходников в папку с датой бэкапа. (0 уровень)
- VSS и основы CVS/SVN в качестве пользователя. (1 уровень)
- Уверенные навыки в CVS и SVN. Знать как создать, разветвить, слить репозиторий и т.д. (2 уровень)
- Знает распределенные системы контроля версий. Уметь работать с Mercurial/Darcs/Git (3 уровень)
* Автоматизация билдов
- Знать, как запускать build из среды программирования (0 уровень)
- Уметь билдить из командной строки (1 уровень)
- Уметь настраивать скрипты для сборки основной системы (2 уровень)
- Уметь настраивать скрипт для сборки системы и документации, для сборки инсталляторов. Уметь составлять и добавлять код скрипта в систему контроля версий исходников.
83) Блок "поставки Agile"

84) scrum, kanban, lean
85) estimation techniques
86) agile project management software
- jira
- rally
- MS Project
- Assembla
- YouTrack
- Trello
87) agile ceremonies (стендап, ретро, демо и проч.)
88) stories and ACs (story definition, acceptance criteria definition, story estimation techniques)
89) commercial agile
90) agile in the enterprise (Scaled Agile - SAFe, LeSS, Nexus, etc.)
91) objections to agile
92) Блок "роль и обязанности тестировщика"

93) example approaches
- Microsoft Combined Engineering Approach (https://learn.microsoft.com/en-us/devops/develop/shift-left-make-testing-fast-reliable)
- Atlassian Qality Assistance Model (https://www.atlassian.com/inside-atlassian/qa)
- Spotify Model (https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf)
- Google Model(https://www.amazon.com/Google-Tests-Software-James-Whittaker/dp/0321803027)
- Slalom Build's Quality Engineering Core Principles (https://medium.com/slalom-build/quality-engineering-core-principles-13cbc34bf389)
94) Исторические роли
95) quality gates
96) Quality Assurance (QA: ) vs Quality Control [https://www.guru99.com/all-about-quality-assurance.html]
97) Блок "юнит-тестирование" (оно же "модульное" тестирование, выполняется разрабами, но разбираться в нём нужно и тестерам)

98) TDD для создания тестов
99) functional and OO Unit Testing (разница между юнит-тестами в функциональных и ООП языках)
100) Mocking / Code Isolation
101) Mutation Testing (паттерны, упрощающие тестирование)
102) Language Specific Frameworks
102.1) Java Frameworks
- JUnit
- TestNG
- NUnit
- Mockito
- EasyMock
102.2) JavaScript Frameworks
- Jest
- Jasmine
- Mocha
102.3) Python Frameworks
- PyTest
* Продвинутый уровень - умение создавать автоматические тесты на функционал, пользовательский интерфейс и загрузку/производительность
104) Блок "автоматизация API"

105) Инструменты:
- PostMan
- Fiddler
- Insomnia
- JUnit (тест-раннер) через библиотеку взаимодействия с сервисом по типу HttpClient и т.н. библиотеки матчеров, проверяющей ассерты (Hamcrest)
106) API Test Frameworks
- RestAssured
- Karate
107) API GUI Tools
108) Contract Testing
- Pact.io
- Swagger
109) Тестирование REST-сервисов
110) Тестирование веб-сервисов
111) Тестирование SOAP-сервисов
112) Тестирование запросов в рамках стриминговых архитектур
113) Тестирование файловых интерфейсов
114) Тестирование бинарных протоколов (возможно, но не обязательно)
115) Блок "автоматизация web UI или веб-интерфейсов"

116) Лимиты UI автоматизации
117) codeless / record playback web automation
- Ranorex
- Katalon Studio
- TestComplete
118) headless browsers
119) POM / UI patterns
120) Web UI Frameworks
120.1) Non-Selenium
- Cypress
- Ruppeteer
- Playwright
- Soap UI
- Karateframework
- QA Wolf
- Jasmine
- Nightwatch
- Robot
- Jest
120.2) Selenium Based
120.3) Framework Design
120.4) Selectors
120.5) Web Driver Protocol
- WebDriver / RC
- WebDriver.io
- Protractor
- Watir
- Appium (оболочки и производные Selenium)
121) open-source инструменты для автоматизированного тестирования
122) Блок "непрерывная интеграция, поставка и развёртывание"

123) Branching Strategies
- trunk
- feature
- GitFlow
- GitHubFlow
124) Collaboration, Pull Requests
125) Hosting Platforms
- GitHub
- BitBucket
- AWS CodeCommit
126) Configuration and Build
127) Artifact repos, versioning
128) Контейнеры
- docker
- kubernetes
129) "инфраструктура как код"
130) интеграция с автоматизацией, работа со скриптами в Cloud Formation или тому подобных инструментах
131) feature flags, toggles
132) environments, ephemeral
133) deployment and release
134) remote execution / device farms
- SauceLabs
- BrowserStack
- AWS Device Farm
135) Оркестрация
- Jenkins (написание пайплайнов)
- CircleCI
- AWS CodePipeline
- TeamCity
136) Блок "тестирование производительности"

137) taxonomy
- load
- stress
- soak
- resilency
138) in pipeline
139) in agile
140) Инструменты
- Apache JMeter / Blazemeter
- Artillery
- Gatling
- Locust
141) Блок "тестирование мобильных приложений"

142) native, hybrid, mobile web (нативные приложения, гибридные приложения, мобильные интерфейсы)
143) iOS Specific
- XCUTest
144) Android Specific (между тестированием на android и ios есть существенные различия)
- Espresso
145) Cross-Platform Frameworks
- Xamarin
- React Native
- Titanium
- Appium
146) Distribution & Release
147) Device Farms
148) Emulator vs Simulator
149) Mobile Automation Tools
150) Mobile Specific Testing
- Device Configuration
- Mobile Performance
- Phone and OS Compat
- Connection Testing
- Mobile Security
151) Блок "тестирование доступности" (к слову о людях с ограниченными возможностями)

152) 508 US Accessibility Standards
153) WCAG 2 (Web Content Accessibility Guidelines, созданы Консорциумом W3)
154) Scanning Tools
- Chrome DevTools Audit
- Wave
- SortSite
- Axe
155) Блок "тестирование безопасности"

156) Аутентификация и авторизация
157) Векторы атаки
158) Поверхность атаки
159) Пентесты (тестирование на проникновение)
160) Криптография (в т.ч. открытые ключи)
161) OWASP Top 10 (Open Web Application Security Project, перечень 10 наиболее опасных уязвимостей)
162) Сканеры уязвимостей
163) Управление защищёнными данными (с ограниченным доступом)
164) Блок "тестирование искуственного интеллекта"

165) + over 200 задач только по этой теме
166) Блок "тестирование в машинном обучении"

167) + ещё 300 задач
168) Блок "тестирование в BigData"
169) + ещё много задач :)

168) 
Дополнить эту карту видами тестирования с фотографии "software testing_classification.png" 
(path to png: D:/1_Аскер/1_Главное/3_ДПО и повышение квалификации/1_GeekBrains/Ручной тестировщик ПО/100001_Иные полезные материалы по IT)


Классификация видов тестирования (для общего развития - в дальнейшем добавить в общий пул задач и как-то классифицировать)

1) По запуску кода на исполнение
1.1) Статическое
1.2) Динамическое

2) По уровню детализации приложения (по уровню тестирования)
2.1) Модульное тестирование
2.2) Интеграционное тестирование
2.3) Системное тестирование

3) По фокусировке на уровне архитектуры приложения
3.1) Уровень представления
3.2) Уровень бизнес-логики
3.3) Уровень данных

4) По доступу к коду и архитектуре приложения
4.1) Метод белого ящика
4.2) Метод серого яшика
4.3) Метод чёрного ящика

5) По убыванию степени важности тестируемых функций (по уровню функционального тестирования)
5.1) "Дымовое" (смоук)
5.2) Критического пути
5.3) Расширенное

6) По привлечению конечных пользователей
6.1) Альфа-тестирование
6.2) Бета-тестирование
6.3) Гамма-тестирование

7) По степени автоматизации
7.1) Ручное
7.2) Автоматизированное (и "автоматическое")

8) По природе приложения
8.1) Веб
8.2) Мобильное
8.3) Настольное (десктоп)
8.4) и другие

9) По степени формализации
9.1) На основе тест-кейсов
9.2) Исследовательское
9.3) Свободное (интуитивное)

10) По целям и задачам
10.1) По прицнипам работы с приложением
10.1.1) Позитивное
10.1.2) Негативное
10.2) Удобства использования
10.3) Доступности
10.4) Интерфейса
10.5) Безопасности
10.6) Интернационализации
10.7) Локализации
10.8) Совместимости
10.8.1) Конфигурационное
10.8.2) Кроссбраузерное
10.9) Сравнительное
10.10) Демонстрационное
10.11) Функциональное
10.12) Нефункциональное
10.13) Надёжности
10.14) Восстанавливаемости
10.15) Отказоустойчивости
10.16) Данных и баз данных
10.17) Использования ресурсов
10.18) Производительности
10.18.1) Нагрузочное
10.18.2) Масштабируемости
10.18.3) Объёмное
10.18.4) Стрессовое
10.18.5) Конкурентное
10.19) Инсталяционное
10.20) Регрессионное
10.21) Повторное
10.22) Приёмочное

11) По техникам автоматизации
11.1) Под управлением данными
11.2) Под управлением ключевыми словами
11.3) Под управлением поведением

12) На основе структур кода
12.1) Выражений
12.2) Ветвей
12.3) Условий
12.4) Комбинации условий
12.5) Решений
12.6) Решающих условий
12.7) Путей

13) По техникам и подходам
13.1) Позитивное
13.2) Негативное

13.1.1) На основе опыта тестировщика, сценариев, чек-листов
13.1.1.1) Исследовательское
13.1.1.2) Свободное (интуитивное)

13.2.1) По степени вмешательства в работу приложения
13.2.1.1) Инвазивное
13.2.1.2) Неинвазивное

13.3.1) На основе знания источников ошибок
13.3.1.1) Предугадывание ошибок
13.3.1.2) Эвристическая ошибка
13.3.1.3) Добавление ошибок
13.3.1.4) Мутационное

13.4.1) На основе выбора входных данных
13.4.1.1) На основе классов эквивалентности
13.4.1.2) На основе граничных условий
13.4.1.3) Доменное
13.4.1.4) Попарное
13.4.1.5) На основе ортогональных массивов

13.5.1) На основе среды выполнения
13.5.1.1) Тестирование в процессе разработки
13.5.1.1) Операционное тестирование

13.6.1) На основе кода
13.6.1.1) По потоку управления
13.6.1.2) По потоку данных
13.6.1.3) По диаграмме или таблице состояний
13.6.1.4) Инспекция (аудит) кода

13.7.1) На основе моделей поведения приложения
13.7.1.1) По таблице принятия решений
13.7.1.2) По диаграмме или таблице состояний
13.7.1.3) По спецификациям
13.7.1.4) По моделям поведения приложения
13.7.1.5) На основе вариантов использования
13.7.1.6) Параллельное
13.7.1.7) На основе случайных данных
13.7.1.8) A / B

14) По моменту выполнения (хронологии)
14.1) Общая универсальная логика последовательности тестирования
14.1.1) Позитивное простое
14.1.2) (далее) Негативное простое
14.1.3) (затем) Позитивное сложное
14.1.4) (в завершении) Негативное сложное

14.2) По иерархии компонентов
14.2.1) Восходящее
14.2.2) Нисходящее
14.2.3) Гибридное

14.3) По концентрации внимания на требованиях и их составляющих
14.3.1) Тестирование требований
14.3.2) Тестирование функциональных составляющих
14.3.3) Тестирование нефункциональных составляющих

18) Типичные общие сценарии
18.1) 1-й сценарий
18.1.1) Дымовое ("смоук")
18.1.2) Критического пути
18.1.3) Расширенное

18.2) 2-й сценарий
18.2.1) Модульное тестирование ↔ Гибридное тестирование
18.2.2) Гибридное тестирование ↔ Интеграционное тестирование
18.2.3) Интеграционное тестирование ↔ Гибридное тестирование
18.2.4) Гибридное тестирование ↔ Системное тестирование
18.2.5) Системное тестирование ↔ Гибридное тестирование

18.3) 3-й сценарий
18.3.1) Альфа-тестирование ↔ Приёмочное тестирование
18.3.2) Приёмочное тестирование → Операционное тестирование
18.3.3) Операционное тестирование → Приёмочное тестирование
18.3.4) Приёмочное тестирование ↔ Бета-тестирование
18.3.5) Бета-тестирование ↔ Приёмочное тестирование
18.3.6) Приёмочное тестирование → Операционное тестирование
18.3.7) Операционное тестирование → Приёмочное тестирование
18.3.8) Приёмочное тестирование ↔ Гамма-тестирование
18.3.9) Гамма-тестирование ↔ Приёмочное тестирование
18.3.10) Приёмочное тестирование → Операционное тестирование


Затем дополнить инфой с вебинара о знакомстве со специализациями.
(path to txt file: D:/1_Аскер/1_Главное/3_ДПО и повышение квалификации/1_GeekBrains/Ручной тестировщик ПО/4_Знакомство со специализациями IT_вебинарный курс/Специализации в IT_конспект видео)